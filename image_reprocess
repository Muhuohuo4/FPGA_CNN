module image_reprocess (
    input wire clk,
    input wire rst,
    input wire start,
    input wire signed [23:0] input_scale,     // Q8.16=Q16.8
    output reg valid,
    output reg done
);
    // ROM 数据
    (* rom_style = "block" *) reg [7:0] channel_1 [0:16899];
    (* rom_style = "block" *) reg [7:0] channel_2 [0:16899];
    (* rom_style = "block" *) reg [7:0] channel_3 [0:16899];

   // BRAM 输出缓存（带白边）130x130 = 16900
    (* ram_style = "block" *) reg signed [7:0] channel_4 [0:16899];
    (* ram_style = "block" *) reg signed [7:0] channel_5 [0:16899];
    (* ram_style = "block" *) reg signed [7:0] channel_6 [0:16899];

    // 初始化文件（仿真用）
    initial $readmemh("R.mem", channel_1);
    initial $readmemh("G.mem", channel_2);
    initial $readmemh("B.mem", channel_3);

    // 控制信号
    reg        [13:0] addr;
    reg        [1:0]  channel;

    // 中间变量
    reg        [7:0]  pixel;
    
    wire [6:0] row = addr / 128;
    wire [6:0] col = addr % 128;
    wire [13:0] addr_pad = (row + 1) * 130 + (col + 1);
    
    wire signed [15:0] pixel_q8_8 = pixel << 8;              // Q8.8
    wire signed [31:0] norm  = pixel_q8_8 * input_scale;      // Q16.16
    wire signed [15:0] result = norm[31:16] - 16'sd128;       // Q8.16
    wire signed [7:0]  data_out <= (result > 127) ? 8'sd127 :
                       (result < -128) ? -8'sd128 :
                       $signed({result[15], result[6:0]});

    // FSM 控制
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            addr <= 0;
            channel <= 0;
            done <= 0;
        end else if (start && !done) begin
            // Step 1: 读像素
            case (channel)
                2'd0: pixel <= channel_1[addr];
                2'd1: pixel <= channel_2[addr];
                2'd2: pixel <= channel_3[addr];
                default: pixel <= 0;
            endcase

            case (channel)
                2'd0: channel_4[addr_pad] <= data_out;
                2'd1: channel_5[addr_pad] <= data_out;
                2'd2: channel_6[addr_pad] <= data_out;
            endcase
            // Step 4: 地址递增
            if (addr == 14'd16383) begin
                addr <= 0;
                if (channel == 2)
                    done <= 1;
                else
                    channel <= channel + 1;
            end else begin
                addr <= addr + 1;
            end
        end
    end


endmodule
